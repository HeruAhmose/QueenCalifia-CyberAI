"""
QueenCalifia CyberAI - Vulnerability Analysis Engine
=====================================================
Real-time vulnerability scanning, CVE correlation, configuration
auditing, and automated remediation guidance.

Spider Web Mapping: Each asset is a node; vulnerabilities are broken threads.
    Scanning traces every thread to find weaknesses before attackers do.

Capabilities:
    - Network service enumeration and vulnerability assessment
    - CVE database correlation with CVSS scoring
    - Configuration compliance auditing (CIS, NIST, DISA STIG)
    - Remediation playbook generation
    - Asset inventory and attack surface mapping
    - Continuous vulnerability monitoring
"""

import re
import uuid
import json
import socket
import hashlib
import logging
import ipaddress
import time
import threading
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum, IntEnum
from collections import defaultdict, deque
from concurrent.futures import ThreadPoolExecutor, as_completed

logger = logging.getLogger("queencalifia.vulnscan")


def _utcnow() -> str:
    return datetime.utcnow().isoformat(timespec="seconds") + "Z"


class ScanTargetPolicy:
    """Allowlist enforcement for scan targets (defense-grade default)."""

    def __init__(self, allowlist: str, deny_public: bool = True):
        import ipaddress

        self.deny_public = deny_public
        self.allowed_networks = []
        allowlist = (allowlist or "").strip()
        if allowlist:
            for part in allowlist.split(","):
                part = part.strip()
                if not part:
                    continue
                self.allowed_networks.append(ipaddress.ip_network(part, strict=False))

        if not self.allowed_networks:
            self.allowed_networks = [
                ipaddress.ip_network("10.0.0.0/8"),
                ipaddress.ip_network("172.16.0.0/12"),
                ipaddress.ip_network("192.168.0.0/16"),
                ipaddress.ip_network("127.0.0.0/8"),
                ipaddress.ip_network("169.254.0.0/16"),
            ]

    def assert_ip_allowed(self, ip: str) -> None:
        import ipaddress

        addr = ipaddress.ip_address(ip)
        if self.deny_public and not (addr.is_private or addr.is_loopback or addr.is_link_local):
            raise ValueError("public IP targets are denied by policy")
        if not any(addr in n for n in self.allowed_networks):
            raise ValueError("target IP not in allowlist")




class VulnSeverity(IntEnum):
    NONE = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4


class ComplianceFramework(Enum):
    CIS = "CIS Benchmarks"
    NIST_800_53 = "NIST SP 800-53"
    NIST_CSF = "NIST Cybersecurity Framework"
    DISA_STIG = "DISA STIG"
    PCI_DSS = "PCI DSS"
    HIPAA = "HIPAA"
    SOC2 = "SOC 2"


class AssetType(Enum):
    SERVER = "server"
    WORKSTATION = "workstation"
    NETWORK_DEVICE = "network_device"
    CLOUD_INSTANCE = "cloud_instance"
    CONTAINER = "container"
    IOT_DEVICE = "iot_device"
    WEB_APPLICATION = "web_application"
    DATABASE = "database"
    API_ENDPOINT = "api_endpoint"


@dataclass
class Vulnerability:
    """Discovered vulnerability with full context"""
    vuln_id: str = field(default_factory=lambda: f"QC-{uuid.uuid4().hex[:8].upper()}")
    cve_id: Optional[str] = None
    title: str = ""
    description: str = ""
    severity: VulnSeverity = VulnSeverity.MEDIUM
    cvss_score: float = 0.0
    cvss_vector: str = ""
    affected_asset: str = ""
    affected_component: str = ""
    affected_version: str = ""
    exploit_available: bool = False
    exploit_maturity: str = "unproven"  # unproven, poc, functional, weaponized
    remediation: str = ""
    remediation_effort: str = "medium"  # low, medium, high
    references: List[str] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    compliance_violations: List[str] = field(default_factory=list)
    first_discovered: datetime = field(default_factory=datetime.utcnow)
    last_seen: datetime = field(default_factory=datetime.utcnow)
    status: str = "open"  # open, remediated, accepted, false_positive


@dataclass
class Asset:
    """Discovered network asset"""
    asset_id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    ip_address: Optional[str] = None
    hostname: Optional[str] = None
    mac_address: Optional[str] = None
    asset_type: AssetType = AssetType.SERVER
    operating_system: Optional[str] = None
    os_version: Optional[str] = None
    open_ports: List[int] = field(default_factory=list)
    services: Dict[int, Dict[str, str]] = field(default_factory=dict)
    vulnerabilities: List[str] = field(default_factory=list)  # vuln_ids
    risk_score: float = 0.0
    last_scanned: datetime = field(default_factory=datetime.utcnow)
    tags: List[str] = field(default_factory=list)
    compliance_status: Dict[str, str] = field(default_factory=dict)


@dataclass
class ScanResult:
    """Complete scan result"""
    scan_id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    scan_type: str = "full"
    target: str = ""
    start_time: datetime = field(default_factory=datetime.utcnow)
    end_time: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """JSON-safe representation."""
        return {
            "scan_id": self.scan_id,
            "scan_type": self.scan_type,
            "target": self.target,
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "assets_discovered": self.assets_discovered,
            "vulnerabilities_found": self.vulnerabilities_found,
            "critical_count": self.critical_count,
            "high_count": self.high_count,
            "medium_count": self.medium_count,
            "low_count": self.low_count,
            "compliance_findings": self.compliance_findings,
            "risk_score": self.risk_score,
        }
    assets_discovered: int = 0
    vulnerabilities_found: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    compliance_findings: int = 0
    risk_score: float = 0.0


class VulnerabilityEngine:
    """
    Queen Califia Vulnerability Analysis Engine
    
    Performs comprehensive vulnerability assessment including:
    - Service fingerprinting and version detection
    - CVE correlation against known vulnerability databases
    - Configuration compliance auditing
    - Attack surface mapping
    - Risk scoring and prioritization
    - Automated remediation guidance
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}

        # Concurrency guard for shared inventories
        self._lock = threading.RLock()

        # Defense-grade scan target policy (deny public unless allowlisted)
        self._target_policy = ScanTargetPolicy(
            allowlist=self.config.get('target_allowlist', ''),
            deny_public=bool(self.config.get('deny_public_targets', True)),
        )

        # Asset inventory
        self.assets: Dict[str, Asset] = {}
        self.asset_index_by_ip: Dict[str, str] = {}

        # Vulnerability database
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.cve_database = self._load_cve_knowledge_base()

        # Compliance rules
        self.compliance_rules = self._load_compliance_rules()

        # Service fingerprints
        self.service_fingerprints = self._load_service_fingerprints()

        # Scan history
        self.scan_history: List[ScanResult] = []

        # Thread pool for parallel scanning
        self.executor = ThreadPoolExecutor(
            max_workers=self.config.get("scan_threads", 16),
            thread_name_prefix="qc_vuln"
        )

        # Async scan job manager
        self.jobs = ScanJobManager(
            engine=self,
            max_scans_per_minute=int(self.config.get("max_scans_per_minute", 10)),
        )

        # Scan rate limiting
        self.scan_rate_limit = self.config.get("max_scans_per_minute", 10)
        self.last_scan_times: List[datetime] = []

        logger.info(
            f"ðŸ” Vulnerability Engine initialized | "
            f"{len(self.cve_database)} CVEs loaded | "
            f"{len(self.compliance_rules)} compliance rules"
        )

    # â”€â”€â”€ CVE Knowledge Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _load_cve_knowledge_base(self) -> Dict[str, Dict[str, Any]]:
        """
        Load CVE knowledge base. In production, this would connect to
        NVD API, CISA KEV, and commercial threat intel feeds.
        This provides a representative set for demonstration.
        """
        return {
            # Critical infrastructure CVEs
            "CVE-2024-3400": {
                "title": "Palo Alto PAN-OS Command Injection",
                "cvss": 10.0,
                "severity": VulnSeverity.CRITICAL,
                "affected": "Palo Alto PAN-OS GlobalProtect",
                "versions": "< 10.2.9-h1, < 11.0.4-h1, < 11.1.2-h3",
                "exploit_maturity": "weaponized",
                "mitre": ["T1190", "T1059"],
                "remediation": "Update PAN-OS to patched version immediately. Apply vendor hotfix.",
                "cisa_kev": True,
            },
            "CVE-2024-21887": {
                "title": "Ivanti Connect Secure Command Injection",
                "cvss": 9.1,
                "severity": VulnSeverity.CRITICAL,
                "affected": "Ivanti Connect Secure / Policy Secure",
                "versions": "< 9.1R18.3, < 22.x patched",
                "exploit_maturity": "weaponized",
                "mitre": ["T1190", "T1059"],
                "remediation": "Apply Ivanti patches. Perform factory reset if compromised.",
                "cisa_kev": True,
            },
            "CVE-2023-44228": {
                "title": "Apache Log4j Remote Code Execution (Log4Shell)",
                "cvss": 10.0,
                "severity": VulnSeverity.CRITICAL,
                "affected": "Apache Log4j",
                "versions": "2.0 - 2.17.0",
                "exploit_maturity": "weaponized",
                "mitre": ["T1190", "T1059.004"],
                "remediation": "Update Log4j to 2.17.1+. Remove JndiLookup class as interim mitigation.",
                "cisa_kev": True,
            },
            "CVE-2024-23897": {
                "title": "Jenkins Arbitrary File Read",
                "cvss": 9.8,
                "severity": VulnSeverity.CRITICAL,
                "affected": "Jenkins",
                "versions": "< 2.442, < LTS 2.426.3",
                "exploit_maturity": "functional",
                "mitre": ["T1190", "T1005"],
                "remediation": "Update Jenkins to 2.442+ or LTS 2.426.3+.",
                "cisa_kev": True,
            },
            "CVE-2024-1709": {
                "title": "ConnectWise ScreenConnect Authentication Bypass",
                "cvss": 10.0,
                "severity": VulnSeverity.CRITICAL,
                "affected": "ConnectWise ScreenConnect",
                "versions": "< 23.9.8",
                "exploit_maturity": "weaponized",
                "mitre": ["T1190", "T1078"],
                "remediation": "Update ScreenConnect to 23.9.8+. Audit for unauthorized access.",
                "cisa_kev": True,
            },
            # Common web vulnerabilities
            "CVE-2024-0001-TEMPLATE-SQLI": {
                "title": "SQL Injection in Web Application",
                "cvss": 8.6,
                "severity": VulnSeverity.HIGH,
                "affected": "Web Application (Generic)",
                "versions": "varies",
                "exploit_maturity": "functional",
                "mitre": ["T1190"],
                "remediation": "Implement parameterized queries. Deploy WAF rules. Input validation.",
                "cisa_kev": False,
            },
            "CVE-2024-0002-TEMPLATE-XSS": {
                "title": "Cross-Site Scripting (XSS)",
                "cvss": 6.1,
                "severity": VulnSeverity.MEDIUM,
                "affected": "Web Application (Generic)",
                "versions": "varies",
                "exploit_maturity": "functional",
                "mitre": ["T1189"],
                "remediation": "Implement output encoding. Set Content-Security-Policy headers.",
                "cisa_kev": False,
            },
            # SSH / TLS
            "CVE-2023-48795": {
                "title": "SSH Terrapin Attack (Prefix Truncation)",
                "cvss": 5.9,
                "severity": VulnSeverity.MEDIUM,
                "affected": "OpenSSH",
                "versions": "< 9.6",
                "exploit_maturity": "poc",
                "mitre": ["T1557"],
                "remediation": "Update OpenSSH to 9.6+. Disable chacha20-poly1305 and CBC-EtM ciphers.",
                "cisa_kev": False,
            },
            "CVE-2024-0001-TEMPLATE-TLS": {
                "title": "Weak TLS Configuration",
                "cvss": 5.3,
                "severity": VulnSeverity.MEDIUM,
                "affected": "TLS Configuration",
                "versions": "TLS 1.0/1.1",
                "exploit_maturity": "functional",
                "mitre": ["T1557"],
                "remediation": "Enforce TLS 1.2+. Disable weak cipher suites. Enable HSTS.",
                "cisa_kev": False,
            },
        }

    def _load_compliance_rules(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load compliance checking rules"""
        return {
            ComplianceFramework.CIS.value: [
                {
                    "rule_id": "CIS-1.1",
                    "title": "Ensure password expiration is 365 days or less",
                    "category": "identity",
                    "check": "password_max_age <= 365",
                    "severity": VulnSeverity.MEDIUM,
                    "remediation": "Set password maximum age to 365 days or less",
                },
                {
                    "rule_id": "CIS-1.2",
                    "title": "Ensure minimum password length is 14+ characters",
                    "category": "identity",
                    "check": "password_min_length >= 14",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Configure minimum password length to 14 characters",
                },
                {
                    "rule_id": "CIS-2.1",
                    "title": "Ensure firewall is enabled",
                    "category": "network",
                    "check": "firewall_enabled == True",
                    "severity": VulnSeverity.CRITICAL,
                    "remediation": "Enable host firewall and configure default-deny rules",
                },
                {
                    "rule_id": "CIS-3.1",
                    "title": "Ensure audit logging is enabled",
                    "category": "audit",
                    "check": "audit_logging_enabled == True",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Enable comprehensive audit logging per CIS guidelines",
                },
                {
                    "rule_id": "CIS-4.1",
                    "title": "Ensure SSH root login is disabled",
                    "category": "endpoint",
                    "check": "ssh_root_login == False",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Set PermitRootLogin no in sshd_config",
                },
                {
                    "rule_id": "CIS-5.1",
                    "title": "Ensure encryption at rest is enabled",
                    "category": "data",
                    "check": "encryption_at_rest == True",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Enable full disk encryption (LUKS, BitLocker, FileVault)",
                },
            ],
            ComplianceFramework.NIST_800_53.value: [
                {
                    "rule_id": "AC-2",
                    "title": "Account Management",
                    "category": "identity",
                    "check": "account_management_policy == True",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Implement automated account management procedures",
                },
                {
                    "rule_id": "AU-2",
                    "title": "Audit Events",
                    "category": "audit",
                    "check": "audit_events_defined == True",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Define and monitor all required audit events",
                },
                {
                    "rule_id": "SC-8",
                    "title": "Transmission Confidentiality and Integrity",
                    "category": "network",
                    "check": "tls_version >= 1.2",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Enforce TLS 1.2+ for all data in transit",
                },
                {
                    "rule_id": "IA-5",
                    "title": "Authenticator Management",
                    "category": "identity",
                    "check": "mfa_enabled == True",
                    "severity": VulnSeverity.CRITICAL,
                    "remediation": "Enforce MFA for all privileged and remote access",
                },
                {
                    "rule_id": "SI-2",
                    "title": "Flaw Remediation",
                    "category": "endpoint",
                    "check": "patch_compliance >= 95",
                    "severity": VulnSeverity.HIGH,
                    "remediation": "Maintain 95%+ patch compliance within 30-day SLA",
                },
            ],
        }

    def _load_service_fingerprints(self) -> Dict[int, Dict[str, Any]]:
        """Load service fingerprint database for port/service identification"""
        return {
            21: {"service": "FTP", "risk": "high", "common_vulns": ["anonymous_login", "cleartext_auth"]},
            22: {"service": "SSH", "risk": "medium", "common_vulns": ["weak_ciphers", "old_version"]},
            23: {"service": "Telnet", "risk": "critical", "common_vulns": ["cleartext_protocol"]},
            25: {"service": "SMTP", "risk": "medium", "common_vulns": ["open_relay", "no_tls"]},
            53: {"service": "DNS", "risk": "medium", "common_vulns": ["zone_transfer", "cache_poisoning"]},
            80: {"service": "HTTP", "risk": "medium", "common_vulns": ["no_tls_redirect", "default_config"]},
            110: {"service": "POP3", "risk": "high", "common_vulns": ["cleartext_auth"]},
            135: {"service": "MSRPC", "risk": "high", "common_vulns": ["remote_exploitation"]},
            139: {"service": "NetBIOS", "risk": "high", "common_vulns": ["smb_exposure"]},
            143: {"service": "IMAP", "risk": "medium", "common_vulns": ["cleartext_auth"]},
            443: {"service": "HTTPS", "risk": "low", "common_vulns": ["weak_tls", "cert_issues"]},
            445: {"service": "SMB", "risk": "critical", "common_vulns": ["eternalblue", "smb_signing"]},
            1433: {"service": "MSSQL", "risk": "critical", "common_vulns": ["sa_account", "no_encryption"]},
            1521: {"service": "Oracle DB", "risk": "critical", "common_vulns": ["default_creds", "tns_poison"]},
            3306: {"service": "MySQL", "risk": "high", "common_vulns": ["root_no_password", "remote_root"]},
            3389: {"service": "RDP", "risk": "critical", "common_vulns": ["bluekeep", "no_nla"]},
            5432: {"service": "PostgreSQL", "risk": "high", "common_vulns": ["trust_auth", "remote_access"]},
            5900: {"service": "VNC", "risk": "critical", "common_vulns": ["no_auth", "weak_password"]},
            6379: {"service": "Redis", "risk": "critical", "common_vulns": ["no_auth", "remote_access"]},
            8080: {"service": "HTTP-Alt", "risk": "medium", "common_vulns": ["admin_panels", "debug_mode"]},
            8443: {"service": "HTTPS-Alt", "risk": "low", "common_vulns": ["weak_tls"]},
            9200: {"service": "Elasticsearch", "risk": "critical", "common_vulns": ["no_auth", "exposed"]},
            27017: {"service": "MongoDB", "risk": "critical", "common_vulns": ["no_auth", "exposed"]},
        }

    # â”€â”€â”€ Scanning Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


    def submit_scan(self, target: str, scan_type: str = "full") -> Dict[str, Any]:
        """Queue an asynchronous scan job."""
        return self.jobs.submit(target=target, scan_type=scan_type)

    def get_scan_job(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """Fetch scan job status/result by id."""
        return self.jobs.get(scan_id)

    def scan_target(
        self,
        target: str,
        scan_type: str = "full",
        scan_id: Optional[str] = None,
        port_range: Optional[Tuple[int, int]] = None,
        compliance_frameworks: Optional[List[str]] = None,
    ) -> ScanResult:
        """
        Execute a comprehensive vulnerability scan against a target.
        
        Args:
            target: IP address, CIDR range, or hostname
            scan_type: "full", "quick", "compliance", "web_app"
            port_range: Custom port range (start, end)
            compliance_frameworks: Frameworks to check against
        """
        scan_id = scan_id or uuid.uuid4().hex[:12]
        scan = ScanResult(scan_id=scan_id, scan_type=scan_type, target=target)

        logger.info(f"ðŸ” Starting {scan_type} scan of {target} [scan:{scan.scan_id}]")

        try:
            # Resolve targets
            targets = self._resolve_targets(target)

            # Phase 1: Asset Discovery & Port Scanning
            for ip in targets:
                asset = self._discover_asset(ip, port_range)
                if asset:
                    with self._lock:
                        self.assets[asset.asset_id] = asset
                        self.asset_index_by_ip[ip] = asset.asset_id
                    scan.assets_discovered += 1

                    # Phase 2: Service Fingerprinting
                    self._fingerprint_services(asset)

                    # Phase 3: Vulnerability Assessment
                    vulns = self._assess_vulnerabilities(asset)
                    for vuln in vulns:
                        with self._lock:
                            self.vulnerabilities[vuln.vuln_id] = vuln
                        asset.vulnerabilities.append(vuln.vuln_id)
                        scan.vulnerabilities_found += 1

                        if vuln.severity == VulnSeverity.CRITICAL:
                            scan.critical_count += 1
                        elif vuln.severity == VulnSeverity.HIGH:
                            scan.high_count += 1
                        elif vuln.severity == VulnSeverity.MEDIUM:
                            scan.medium_count += 1
                        elif vuln.severity == VulnSeverity.LOW:
                            scan.low_count += 1

                    # Phase 4: Compliance Checking
                    if compliance_frameworks or scan_type in ("full", "compliance"):
                        frameworks = compliance_frameworks or [
                            ComplianceFramework.CIS.value,
                            ComplianceFramework.NIST_800_53.value,
                        ]
                        findings = self._check_compliance(asset, frameworks)
                        scan.compliance_findings += len(findings)

                    # Calculate risk score
                    asset.risk_score = self._calculate_asset_risk(asset)

            # Calculate overall risk
            if scan.assets_discovered > 0:
                all_risks = [a.risk_score for a in self.assets.values()]
                scan.risk_score = round(max(all_risks) if all_risks else 0, 2)

        except Exception as exc:
            logger.error(f"Scan error: {exc}")

        scan.end_time = datetime.utcnow()
        with self._lock:
            self.scan_history.append(scan)

        logger.info(
            f"âœ… Scan {scan.scan_id} complete | "
            f"assets={scan.assets_discovered} | "
            f"vulns={scan.vulnerabilities_found} | "
            f"critical={scan.critical_count} high={scan.high_count} | "
            f"risk={scan.risk_score}"
        )

        return scan

    def _resolve_targets(self, target: str) -> List[str]:
        """Resolve target specification into list of IPs"""
        targets = []
        try:
            # Check if CIDR
            if "/" in target:
                network = ipaddress.ip_network(target, strict=False)
                targets = [str(ip) for ip in network.hosts()]
                # Cap at 256 for safety
                targets = targets[:256]
            else:
                # Single IP or hostname
                try:
                    ipaddress.ip_address(target)
                    targets = [target]
                except ValueError:
                    # Attempt hostname resolution
                    try:
                        ip = socket.gethostbyname(target)
                        targets = [ip]
                    except socket.gaierror:
                        logger.warning(f"Cannot resolve target: {target}")
        except Exception as exc:
            logger.error(f"Target resolution error: {exc}")

        # Enforce scan policy
        allowed = []
        for ip in targets:
            try:
                self._target_policy.assert_ip_allowed(ip)
                allowed.append(ip)
            except Exception as exc:
                logger.warning(f"Target denied by policy: {ip} ({exc})")
        return allowed

    def _discover_asset(
        self, ip: str, port_range: Optional[Tuple[int, int]] = None
    ) -> Optional[Asset]:
        """Discover asset and enumerate open ports"""
        asset = Asset(
            ip_address=ip,
            asset_type=AssetType.SERVER,
        )

        # Resolve hostname
        try:
            hostname = socket.getfqdn(ip)
            if hostname != ip:
                asset.hostname = hostname
        except Exception:
            pass

        # Port scanning
        ports_to_scan = list(self.service_fingerprints.keys())
        if port_range:
            ports_to_scan = list(range(port_range[0], port_range[1] + 1))

        open_ports = []
        for port in ports_to_scan:
            if self._check_port(ip, port):
                open_ports.append(port)

        asset.open_ports = open_ports

        if not open_ports:
            return None

        return asset

    def _check_port(self, ip: str, port: int, timeout: float = 1.0) -> bool:
        """Check if a TCP port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            return result == 0
        except Exception:
            return False

    def _fingerprint_services(self, asset: Asset):
        """Fingerprint services on open ports"""
        for port in asset.open_ports:
            fingerprint = self.service_fingerprints.get(port, {})
            asset.services[port] = {
                "service": fingerprint.get("service", "unknown"),
                "risk_level": fingerprint.get("risk", "unknown"),
                "version": "unknown",  # Would use banner grabbing in production
            }

    def _assess_vulnerabilities(self, asset: Asset) -> List[Vulnerability]:
        """Assess vulnerabilities based on discovered services and configuration"""
        vulns = []

        for port, service_info in asset.services.items():
            fingerprint = self.service_fingerprints.get(port, {})
            service_name = service_info.get("service", "unknown")

            # Check for inherently risky services
            if fingerprint.get("risk") == "critical":
                vuln = Vulnerability(
                    title=f"Critical Risk Service Exposed: {service_name} on port {port}",
                    description=(
                        f"High-risk service {service_name} is accessible on port {port}. "
                        f"This service is commonly targeted by attackers."
                    ),
                    severity=VulnSeverity.HIGH,
                    cvss_score=7.5,
                    affected_asset=asset.ip_address or asset.asset_id,
                    affected_component=service_name,
                    exploit_available=True,
                    remediation=(
                        f"Restrict access to {service_name} (port {port}) using firewall rules. "
                        f"Ensure strong authentication. Consider network segmentation."
                    ),
                    remediation_effort="medium",
                )
                vulns.append(vuln)

            # Check for known common vulns per service
            for common_vuln in fingerprint.get("common_vulns", []):
                if common_vuln == "cleartext_protocol":
                    vulns.append(Vulnerability(
                        title=f"Cleartext Protocol: {service_name}",
                        description=f"{service_name} on port {port} transmits data in cleartext",
                        severity=VulnSeverity.HIGH,
                        cvss_score=7.4,
                        affected_asset=asset.ip_address or asset.asset_id,
                        affected_component=service_name,
                        mitre_techniques=["T1557", "T1040"],
                        remediation=f"Replace {service_name} with encrypted alternative (e.g., SSH/SFTP for Telnet/FTP)",
                        remediation_effort="medium",
                    ))
                elif common_vuln == "no_auth":
                    vulns.append(Vulnerability(
                        title=f"No Authentication: {service_name}",
                        description=f"{service_name} on port {port} has no authentication configured",
                        severity=VulnSeverity.CRITICAL,
                        cvss_score=9.8,
                        affected_asset=asset.ip_address or asset.asset_id,
                        affected_component=service_name,
                        exploit_available=True,
                        exploit_maturity="functional",
                        mitre_techniques=["T1078"],
                        remediation=f"Enable authentication for {service_name}. Use strong credentials.",
                        remediation_effort="low",
                    ))
                elif common_vuln == "weak_tls":
                    vulns.append(Vulnerability(
                        title=f"Weak TLS Configuration: {service_name}",
                        description=f"{service_name} supports weak TLS versions or cipher suites",
                        severity=VulnSeverity.MEDIUM,
                        cvss_score=5.3,
                        affected_asset=asset.ip_address or asset.asset_id,
                        affected_component="TLS",
                        mitre_techniques=["T1557"],
                        remediation="Enforce TLS 1.2+. Disable CBC and RC4 ciphers. Enable HSTS.",
                        remediation_effort="low",
                    ))

        return vulns

    def _check_compliance(
        self, asset: Asset, frameworks: List[str]
    ) -> List[Dict[str, Any]]:
        """Check asset against compliance frameworks"""
        findings = []

        for framework_name in frameworks:
            rules = self.compliance_rules.get(framework_name, [])
            for rule in rules:
                # Simulate compliance checking (in production, this queries actual config)
                finding = {
                    "rule_id": rule["rule_id"],
                    "framework": framework_name,
                    "title": rule["title"],
                    "severity": rule["severity"].name,
                    "asset": asset.ip_address or asset.asset_id,
                    "status": "requires_review",
                    "remediation": rule["remediation"],
                }
                findings.append(finding)
                asset.compliance_status[rule["rule_id"]] = "requires_review"

        return findings

    def _calculate_asset_risk(self, asset: Asset) -> float:
        """Calculate composite risk score for an asset (0-10)"""
        if not asset.vulnerabilities:
            return 0.0

        vuln_scores = []
        for vuln_id in asset.vulnerabilities:
            vuln = self.vulnerabilities.get(vuln_id)
            if vuln:
                # Weight by CVSS and exploit maturity
                base = vuln.cvss_score
                if vuln.exploit_available:
                    if vuln.exploit_maturity == "weaponized":
                        base *= 1.3
                    elif vuln.exploit_maturity == "functional":
                        base *= 1.15
                vuln_scores.append(min(10.0, base))

        if not vuln_scores:
            return 0.0

        # Risk = max individual + aggregate bonus
        max_risk = max(vuln_scores)
        aggregate_bonus = min(2.0, len(vuln_scores) * 0.1)

        return round(min(10.0, max_risk + aggregate_bonus), 2)

    # â”€â”€â”€ Remediation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def generate_remediation_plan(
        self, asset_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Generate a prioritized remediation plan"""
        target_vulns = []

        if asset_id:
            asset = self.assets.get(asset_id)
            if asset:
                target_vulns = [
                    self.vulnerabilities[vid]
                    for vid in asset.vulnerabilities
                    if vid in self.vulnerabilities
                ]
        else:
            target_vulns = list(self.vulnerabilities.values())

        # Filter to open vulnerabilities
        open_vulns = [v for v in target_vulns if v.status == "open"]

        # Sort by severity (critical first), then by exploit maturity
        maturity_order = {"weaponized": 0, "functional": 1, "poc": 2, "unproven": 3}
        open_vulns.sort(
            key=lambda v: (
                -v.severity.value,
                maturity_order.get(v.exploit_maturity, 4),
                -v.cvss_score,
            )
        )

        plan = {
            "plan_id": str(uuid.uuid4())[:8],
            "generated_at": datetime.utcnow().isoformat(),
            "total_vulnerabilities": len(open_vulns),
            "priority_actions": [],
            "summary": {
                "critical": sum(1 for v in open_vulns if v.severity == VulnSeverity.CRITICAL),
                "high": sum(1 for v in open_vulns if v.severity == VulnSeverity.HIGH),
                "medium": sum(1 for v in open_vulns if v.severity == VulnSeverity.MEDIUM),
                "low": sum(1 for v in open_vulns if v.severity == VulnSeverity.LOW),
            },
        }

        for i, vuln in enumerate(open_vulns[:20]):  # Top 20 priorities
            plan["priority_actions"].append({
                "priority": i + 1,
                "vuln_id": vuln.vuln_id,
                "cve_id": vuln.cve_id,
                "title": vuln.title,
                "severity": vuln.severity.name,
                "cvss_score": vuln.cvss_score,
                "affected_asset": vuln.affected_asset,
                "exploit_available": vuln.exploit_available,
                "exploit_maturity": vuln.exploit_maturity,
                "remediation": vuln.remediation,
                "effort": vuln.remediation_effort,
                "mitre_techniques": vuln.mitre_techniques,
            })

        return plan

    # â”€â”€â”€ Web Application Scanning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def scan_web_application(self, url: str) -> Dict[str, Any]:
        """
        Perform web application vulnerability assessment.
        Checks for OWASP Top 10 categories.
        """
        results = {
            "scan_id": str(uuid.uuid4())[:8],
            "target_url": url,
            "start_time": datetime.utcnow().isoformat(),
            "findings": [],
            "headers_analysis": {},
            "tls_analysis": {},
        }

        # Security headers check
        headers_to_check = {
            "Strict-Transport-Security": {
                "severity": VulnSeverity.HIGH,
                "remediation": "Add 'Strict-Transport-Security: max-age=31536000; includeSubDomains'",
            },
            "Content-Security-Policy": {
                "severity": VulnSeverity.MEDIUM,
                "remediation": "Implement Content-Security-Policy header with restrictive directives",
            },
            "X-Content-Type-Options": {
                "severity": VulnSeverity.LOW,
                "remediation": "Add 'X-Content-Type-Options: nosniff'",
            },
            "X-Frame-Options": {
                "severity": VulnSeverity.MEDIUM,
                "remediation": "Add 'X-Frame-Options: DENY' or 'SAMEORIGIN'",
            },
            "X-XSS-Protection": {
                "severity": VulnSeverity.LOW,
                "remediation": "Add 'X-XSS-Protection: 1; mode=block'",
            },
            "Referrer-Policy": {
                "severity": VulnSeverity.LOW,
                "remediation": "Add 'Referrer-Policy: strict-origin-when-cross-origin'",
            },
            "Permissions-Policy": {
                "severity": VulnSeverity.LOW,
                "remediation": "Add Permissions-Policy header restricting browser features",
            },
        }

        for header, info in headers_to_check.items():
            results["headers_analysis"][header] = {
                "present": False,  # Would check actual headers in production
                "severity": info["severity"].name,
                "remediation": info["remediation"],
            }
            results["findings"].append({
                "type": "missing_security_header",
                "header": header,
                "severity": info["severity"].name,
                "remediation": info["remediation"],
            })

        results["end_time"] = datetime.utcnow().isoformat()
        return results

    # â”€â”€â”€ Status & Reporting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_status(self) -> Dict[str, Any]:
        """Get vulnerability engine status"""
        return {
            "assets_tracked": len(self.assets),
            "vulnerabilities_open": sum(
                1 for v in self.vulnerabilities.values() if v.status == "open"
            ),
            "vulnerabilities_total": len(self.vulnerabilities),
            "severity_breakdown": {
                "critical": sum(
                    1 for v in self.vulnerabilities.values()
                    if v.severity == VulnSeverity.CRITICAL and v.status == "open"
                ),
                "high": sum(
                    1 for v in self.vulnerabilities.values()
                    if v.severity == VulnSeverity.HIGH and v.status == "open"
                ),
                "medium": sum(
                    1 for v in self.vulnerabilities.values()
                    if v.severity == VulnSeverity.MEDIUM and v.status == "open"
                ),
                "low": sum(
                    1 for v in self.vulnerabilities.values()
                    if v.severity == VulnSeverity.LOW and v.status == "open"
                ),
            },
            "cve_database_size": len(self.cve_database),
            "compliance_frameworks": list(self.compliance_rules.keys()),
            "scans_completed": len(self.scan_history),
            "timestamp": datetime.utcnow().isoformat(),
        }


@dataclass
class ScanJob:
    scan_id: str
    target: str
    scan_type: str
    status: str = "queued"  # queued|running|completed|failed
    created_at: str = field(default_factory=_utcnow)
    started_at: Optional[str] = None
    completed_at: Optional[str] = None
    error: Optional[str] = None
    result: Optional[Dict[str, Any]] = None


class ScanJobManager:
    """Async scan queue with global rate limiting (per process)."""

    def __init__(self, engine: "VulnerabilityEngine", max_scans_per_minute: int = 10):
        self.engine = engine
        self.max_scans_per_minute = max(1, int(max_scans_per_minute))
        self._lock = threading.RLock()
        self._jobs: Dict[str, ScanJob] = {}
        self._submitted: deque[float] = deque(maxlen=10_000)

    def submit(self, target: str, scan_type: str) -> Dict[str, Any]:
        now = time.monotonic()
        window_start = now - 60
        with self._lock:
            while self._submitted and self._submitted[0] <= window_start:
                self._submitted.popleft()
            if len(self._submitted) >= self.max_scans_per_minute:
                raise ValueError("scan rate limit exceeded")

            scan_id = uuid.uuid4().hex[:12]
            job = ScanJob(scan_id=scan_id, target=target, scan_type=scan_type)
            self._jobs[scan_id] = job
            self._submitted.append(now)

            self.engine.executor.submit(self._run_job, scan_id)

            return {"scan_id": scan_id, "status": job.status, "target": target, "scan_type": scan_type}

    def _run_job(self, scan_id: str) -> None:
        with self._lock:
            job = self._jobs.get(scan_id)
            if not job:
                return
            job.status = "running"
            job.started_at = _utcnow()

        try:
            scan = self.engine.scan_target(target=job.target, scan_type=job.scan_type, scan_id=scan_id)
            result = scan.to_dict()
            with self._lock:
                job.status = "completed"
                job.completed_at = _utcnow()
                job.result = result
        except Exception as exc:
            with self._lock:
                job.status = "failed"
                job.completed_at = _utcnow()
                job.error = str(exc)

    def get(self, scan_id: str) -> Optional[Dict[str, Any]]:
        with self._lock:
            job = self._jobs.get(scan_id)
            if not job:
                return None
            return {
                "scan_id": job.scan_id,
                "target": job.target,
                "scan_type": job.scan_type,
                "status": job.status,
                "created_at": job.created_at,
                "started_at": job.started_at,
                "completed_at": job.completed_at,
                "error": job.error,
                "result": job.result,
            }

